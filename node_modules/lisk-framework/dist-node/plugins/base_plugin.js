"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const lisk_codec_1 = require("@liskhq/lisk-codec");
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const decodeTransactionToJSON = (transactionBuffer, baseSchema, assetsSchemas) => {
    const baseTransaction = lisk_codec_1.codec.decodeJSON(baseSchema, transactionBuffer);
    const transactionTypeAsset = assetsSchemas.find(s => s.assetID === baseTransaction.assetID && s.moduleID === baseTransaction.moduleID);
    if (!transactionTypeAsset) {
        throw new Error('Transaction type not found.');
    }
    const transactionAsset = lisk_codec_1.codec.decodeJSON(transactionTypeAsset.schema, Buffer.from(baseTransaction.asset, 'hex'));
    return {
        ...baseTransaction,
        id: lisk_cryptography_1.hash(transactionBuffer).toString('hex'),
        asset: transactionAsset,
    };
};
const encodeTransactionFromJSON = (transaction, baseSchema, assetsSchemas) => {
    const transactionTypeAsset = assetsSchemas.find(s => s.assetID === transaction.assetID && s.moduleID === transaction.moduleID);
    if (!transactionTypeAsset) {
        throw new Error('Transaction type not found.');
    }
    const transactionAssetBuffer = lisk_codec_1.codec.encode(transactionTypeAsset.schema, lisk_codec_1.codec.fromJSON(transactionTypeAsset.schema, transaction.asset));
    const transactionBuffer = lisk_codec_1.codec.encode(baseSchema, lisk_codec_1.codec.fromJSON(baseSchema, {
        ...transaction,
        asset: transactionAssetBuffer,
    }));
    return transactionBuffer.toString('hex');
};
const decodeAccountToJSON = (encodedAccount, accountSchema) => {
    const decodedAccount = lisk_codec_1.codec.decodeJSON(accountSchema, encodedAccount);
    return {
        ...decodedAccount,
    };
};
const decodeRawBlock = (blockSchema, encodedBlock) => lisk_codec_1.codec.decode(blockSchema, encodedBlock);
const decodeBlockToJSON = (registeredSchema, encodedBlock) => {
    const { header, payload } = lisk_codec_1.codec.decode(registeredSchema.block, encodedBlock);
    const baseHeaderJSON = lisk_codec_1.codec.decodeJSON(registeredSchema.blockHeader, header);
    const blockAssetJSON = lisk_codec_1.codec.decodeJSON(registeredSchema.blockHeadersAssets[baseHeaderJSON.version], Buffer.from(baseHeaderJSON.asset, 'hex'));
    const payloadJSON = payload.map(transactionBuffer => decodeTransactionToJSON(transactionBuffer, registeredSchema.transaction, registeredSchema.transactionsAssets));
    const blockId = lisk_cryptography_1.hash(header);
    return {
        header: { ...baseHeaderJSON, asset: { ...blockAssetJSON }, id: blockId.toString('hex') },
        payload: payloadJSON,
    };
};
class BasePlugin {
    constructor(options) {
        this.options = options;
        this.codec = {
            decodeAccount: (data) => {
                const accountBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');
                return decodeAccountToJSON(accountBuffer, this.schemas.account);
            },
            decodeBlock: (data) => {
                const blockBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');
                return decodeBlockToJSON(this.schemas, blockBuffer);
            },
            decodeRawBlock: (data) => {
                const blockBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');
                return decodeRawBlock(this.schemas.block, blockBuffer);
            },
            decodeTransaction: (data) => {
                const transactionBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');
                return decodeTransactionToJSON(transactionBuffer, this.schemas.transaction, this.schemas.transactionsAssets);
            },
            encodeTransaction: (transaction) => encodeTransactionFromJSON(transaction, this.schemas.transaction, this.schemas.transactionsAssets),
        };
    }
    async init(channel) {
        channel.once(constants_1.APP_EVENT_READY, async () => {
            this.schemas = await channel.invoke('app:getSchema');
        });
    }
    static get alias() {
        throw new errors_1.ImplementationMissingError();
    }
    static get info() {
        throw new errors_1.ImplementationMissingError();
    }
    get defaults() {
        return {};
    }
}
exports.BasePlugin = BasePlugin;
exports.getPluginExportPath = (pluginKlass, strict = true) => {
    let nodeModule;
    let nodeModulePath;
    try {
        nodeModule = require(pluginKlass.info.name);
        nodeModulePath = pluginKlass.info.name;
    }
    catch (error) {
    }
    if (!nodeModule && pluginKlass.info.exportPath) {
        try {
            nodeModule = require(pluginKlass.info.exportPath);
            nodeModulePath = pluginKlass.info.exportPath;
        }
        catch (error) {
        }
    }
    if (!nodeModule || !nodeModule[pluginKlass.name]) {
        return;
    }
    if (strict && nodeModule[pluginKlass.name] !== pluginKlass) {
        return;
    }
    return nodeModulePath;
};
exports.validatePluginSpec = (PluginKlass) => {
    const pluginObject = new PluginKlass();
    assert(PluginKlass.alias, 'Plugin alias is required.');
    assert(PluginKlass.info.name, 'Plugin name is required.');
    assert(PluginKlass.info.author, 'Plugin author is required.');
    assert(PluginKlass.info.version, 'Plugin version is required.');
    assert(pluginObject.defaults, 'Plugin default options are required.');
    assert(pluginObject.events, 'Plugin events are required.');
    assert(pluginObject.actions, 'Plugin actions are required.');
    assert(pluginObject.load, 'Plugin load action is required.');
    assert(pluginObject.unload, 'Plugin unload actions is required.');
};
//# sourceMappingURL=base_plugin.js.map